# API Security
## 1. Prevent request attempts from outside of allowed network
- Regarding the system is still under a development process, I've assumed that all permitted requests should come from within my **localhost** network and other whitelisted networks
- I installed ip-range-check 
    ```cmd
    npm install ip-range-check
    ```
- Then implemented a middleware function in **utils/ipChecker.js **that checked if the incoming requests have original IP within permitted ranges of different networks: 127.0.0.1 and 192.168.0.0/30
    ```js
    import ipRangeCheck from "ip-range-check"

    const ALLOWED_IPS = ["127.0.0.1", "192.168.0.0/24"];

    export const ipChecker = (req, res, next) => {
        const clientIp = req.ip;

        // Check if the client's IP is in my allowed list
        if (ipRangeCheck(clientIp, ALLOWED_IPS)) {
            // IP is allowed, proceed to the next route
            next();
        } else {
            // IP is not allowed, send a 403 Forbidden error
            console.warn(`Forbidden: Denied access from IP ${clientIp}`);
            res.status(403).json({ message: "Forbidden: You do not have access." });
        }
    };

    ```
- Then, I integrated that middleware function into **index.js**, my Express server also got additional configurations with **app.set('trust proxy', 1)** so that I could simulate the ability of **ipChecker**. Enabling that setting lets my Express server "treat" IP values of header "X-Forwarded-For" as the original IP (or req.ip), so I could test the functionality of IP restriction.
    ```js
    // index.js
    // other imports
    // ...
    import { ipChecker } from "./utils/ipChecker.js";
    // other Express server configurations
    app.set('trust proxy', 1);
    app.use(ipChecker)
    // other middlewares and routes configurations
    //...
    // codes that run the server
    ```
- After starting the server, I sent some sample GET requests to API **films** with VSCode  REST Client 
    ```http
    <!-- 1. Sent from localhost -->
    GET http://localhost:3000/films
    ###
    <!-- 2. "Sent" from IP 8.8.8.8 out of permission  -->
    GET http://localhost:3000/films
    X-Forwarded-For: 8.8.8.8 
    <!-- 3. "Sent" from IP within 192.168.0.0 network  -->
    ###
    GET http://localhost:3000/films
    X-Forwarded-For: 192.168.0.127
    ```
- Their respective responses:
    ```http
    <!-- 1 -->
    HTTP/1.1 200 OK
    <!-- 2 -->
    HTTP/1.1 403 Forbidden
    <!-- 3 -->
    HTTP/1.1 200 OK
    ```
## 2. Prevent request attemps from outsiders and identify them.
- After integrating IP restriction, I proceeded to protects some of my API endpoints from unauthorized requests. I mainly focused on modifying methods (POST, PUT and DELETE), so I started creating authentication and authorization systems.
- First, I created **user** table in database **sakila** using MySQL Workbench, and inserted into its some sample values:
    ```sql
    <!-- user table sql script -->
    CREATE TABLE `user` (
    `user_id` INT NOT NULL AUTO_INCREMENT,
    `username` VARCHAR(45) NOT NULL,
    `password` VARCHAR(255) NOT NULL,
    `created_at` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (`user_id`),
    UNIQUE KEY `username_UNIQUE` (`username`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
    <!-- values insertion -->
    INSERT INTO `sakila`.`user`
    (`user_id`,
    `username`,
    `password`,
    `created_at`)
    VALUES
    (1, 'admin', 'admin_pass123'),
    (2, 'jsmith', 'smithP@ssw0rd'),
    (3, 'test_user', 'test'),
    (4, 'api_service', 'service_key_98765'),
    (5, 'emartinez', 'emily_2025');
    ``` 
- Then, I created **User** model in **models/user.model.js**, preparing for implementing JWT Authentication system
    ```js
    import { DataTypes } from "sequelize";
    import sequelize from "../configs/database.js";
    const User = sequelize.define('User',{
    user_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        primaryKey: true,
        autoIncrement: true 
    },
    
    username: {
        type: DataTypes.STRING(45),
        allowNull: false,
        unique: true 
    },
    
    password: {
        type: DataTypes.STRING(255),
        allowNull: false
    },
    
    created_at: {
        type: DataTypes.DATE, 
        allowNull: false,
        defaultValue: DataTypes.NOW 
    }
    }, {
        tableName: 'user',        
        timestamps: false          
                            
    })

    export default User;
    ```
- I created **controllers/auth.controller.js** and install `jsonwebtoken` using `npm install jsonwebtoken`. Before implementing the controller, I stored JWT_SECRET in `.env` and configured JWT token generator in **utils/token.js**. This generator would embed a `jwt` token in response's header as cookies.
    ```js
    //utils/token.js
    import jwt from "jsonwebtoken"
    export const generateToken = (userId, res) => {
        const token = jwt.sign({userId}, process.env.JWT_SECRET,
            {expiresIn:"7d",}
        )
        res.cookie("jwt", token, {
            maxAge: 7*24*60*60*1000,
            httpOnly: true,
            sameSite: "strict",
            secure: false,
        })

        return token
    }
    ```
- After that, I implemented auth.controller.js, which verifies users' credentials and provides authentication tokens if valid. 
    ```js
    /*
    INSERT INTO `sakila`.`user`
    (`user_id`,
    `username`,
    `password`,
    `created_at`)
    VALUES
    (1, 'admin', 'admin_pass123'),
    (2, 'jsmith', 'smithP@ssw0rd'),
    (3, 'test_user', 'test'),
    (4, 'api_service', 'service_key_98765'),
    (5, 'emartinez', 'emily_2025');

    */

    import User from "../models/user.model.js";
    import Joi from "joi";
    import { generateToken } from "../utils/token.js";
    const JWT_SECRET = process.env.JWT_SECRET

    const schema = Joi.object({
        username: Joi.string().max(45).min(1).required(),
        password: Joi.string().max(255).min(1).required()
    })
    export const login = async (req, res) => {
        // Get req.body as user, find credentials in database sakila 
        if (user){
            generateToken(user?.user_id, res)
            res.json({
                msg: "Login sucessfully"
            })
        }
        // Error handling code
    } 
    ```
- Finishing controller for the **login** endpoint, I implemented a router to handle request toward "localhost:3000/auth/login" in `routes/auth.route.js.` 
    ```js
    //routes/auth.route.js
    import { Router } from "express";
    import { login } from "../controllers/auth.controller.js";
    const authRoute =  Router()
    authRoute.post("/login", login)
    export default authRoute
        
    ```
- Then, I implemented `middlewares/auth.middleware.js`, where all of the auth checking and restriction take places. The logic for this component is sample, it checks all of incoming requests for cookie "jwt", then checks its validation before let them through to next routes. Any steps failed result in `401 Unauthorization` responses.
    ```js
    import jwt from "jsonwebtoken"
    import User from "../models/user.model.js";

    export const protectRoute = async (req, res, next) => {
        const token = req.cookies.jwt;
        console.log("Token: ", token)
        try {
            if (!token){
                res.status(401).json({msg: "Missing token"})
            }
            const decoded = jwt.verify(token, process.env.JWT_SECRET)
            if (!decoded){
                res.status(401).json({msg: "Invalid token"})
            }
            const user = await User.findOne({where: {user_id: decoded.userId}})
            if (!user){
                res.status(401).json({msg: "Invalid User - Please login for new token"})
            }
            req.user = user.username
            next();
        } catch (error) {
            res.status(500).json({message: "Internal Server Error"})
        }
    }
    
    ```
## 3. Put all of the middlewares together
- `protectRoute` serves as a **gate** right before `req` packages get passed into controllers of each endpoints. This is how I integrated it into **films** and **actors** APIs
    ```js
    //routes/actor.route.js
    import { Router } from "express";
    import { getActor, getAllActors, postActor, putActor, deleteActor } from "../controllers/actor.controller.js";
    import { protectRoute } from "../middlewares/auth.middleware.js";
    const actorRoute = Router();

    /*
        Method GET no need to be protected
    */
    actorRoute.post('/', protectRoute, postActor);
    actorRoute.put('/:id', protectRoute, putActor);
    actorRoute.delete('/:id', protectRoute, deleteActor)

    export default actorRoute;
    ```
    ```js
    //routes/film.route.js
    import { Router } from "express";
    import { deleteFilm, getAllFilms, getFilm, postFilm, putFilm } from "../controllers/film.controller.js";
    import { protectRoute } from "../middlewares/auth.middleware.js";
    const filmRoute = Router()
    /*
        Method GET no need to be protected
    */
    filmRoute.post('/', protectRoute, postFilm)
    filmRoute.put('/:id',protectRoute, putFilm)
    filmRoute.delete('/:id', protectRoute, deleteFilm)
    export default filmRoute;
    ```
- But the process was not finished. My Express still needed to let `protectRoute` access cookies in `req`, so I installed `cookie-parser` and added that helper to it. Thus this appeared among other helpers: 
    ```js
    //index.js

    import cookieParser from "cookie-parser";
    // ...
    app.use(cookieParser())
    ```
## 4. Test the JWT Authentication system
- Starting the server, I ran this request using VSCode REST Client to get the authentication tokens, this extension from VSCode did me a favor by storing my JWT tokens after my login request for later requests. 
    ```http
    <!-- auth.request.http -->
    POST http://localhost:3000/auth/login
    Content-Type: application/json

    {
        "username": "admin",
        "password": "admin_pass123"
    }
    ```
- Some of the requests below are set with `@no-cookie-jar` option, which tells REST Client to run such requests without using stored cookies from previously login, thus it was possible to test for "unauthenticated" requests.
    ```http
    <!-- requests/film.request.http -->
    # @no-cookie-jar
    POST http://localhost:3000/films
    Content-Type: application/json

    {
        "language_id": 1,
        "rental_duration": 2,
        "rental_rate": 4.99,
        "replacement_cost": 10.99
    }
    ###
    POST http://localhost:3000/films
    Content-Type: application/json

    {
        "language_id": 1,
        "rental_duration": 2,
        "rental_rate": 4.99,
        "replacement_cost": 10.99
    }
    ###
    ```
- These were their responses:
    ```http
    <!-- With @no-cookie-jar -->
    HTTP/1.1 401 Unauthorized
    <!-- Without @no-cookie-jar -->
    HTTP/1.1 400 Bad Request
    ```
## 5. Additional settings for logging
- I also modified `middlewares/morgan.middleware.js` (formerly `utils/loggerHelper.js`), so that it can log an Additional `reqUser` field when it comes to authorized requests (POST, PUT, DELETE). For example: 
    ```json
    {"contentLength":"126","level":"warn","message":"400 POST /films","reqBody":"{\"language_id\":1,\"rental_duration\":2,\"rental_rate\":4.99,\"replacement_cost\":10.99}","reqIP":"::ffff:127.0.0.1","reqUser":"admin","responseTime":"14.105ms","timestamp":"2025-10-26T11:35:20.316Z"}

    ```