# GA01 - RESTful API
## 1. Create project directory
- I created an empty directory and open VS Code in that folder. Inside that folder I created an folder called "backend" 
- Then, I opened VS Code terminal and run the following command to initialze a NodeJS work folder with type of "module" to use "import" keyword inside "backend" folder. 
    ```powershell
    cd backend
    npm init -y
    npm pkg set type="module"
    ```
## 2. Create index.js and "/" endpoint
- After initializing, I installed all of the initial dependencies using npm install
    ```powershell
    npm install dotenv express mysql2 sequelize nodemon
    ```
- I added a script attribute in **package.json** with this value for ease of development:
    ```json
        "dev": "nodemon index.js"
    ```
- I created index.js to initilze a simple server, running on port 3000. Server only responsed to original endpoint "/".
    ```js
    import express from "express";
    const app = express();
    app.use(express.json());
    const port = 3000;

    app.get('/', (req, res) => {
        res.send('Express connected!');
    });
    app.listen(port, () => {
        console.log("Server running on port: " + port);
    })

    startServer();
    ```
## 3. Setup MySQL Database, configure database connection for ExpressJS Server
- I installed MySQL Server and MySQL Workbench 8 from there dedicated official website [MysSQL Official Website](https://www.mysql.com/)
- I downloaded the prepared .sql script provided by the lecturer and run that script to create a schema (or database) called **sekila**
- I created configs folder where I stored MySQL database connection configuration file called database.js
    ```js
    import {Sequelize} from 'sequelize';
    import { configDotenv } from 'dotenv';
    configDotenv();
    const sequelize = new Sequelize(
        process.env.DB_NAME,
        process.env.DB_USER,
        process.env.DB_PASSWORD,{
            dialect:'mysql',
            host:process.env.DB_HOST,
        }
    )
    export default sequelize
    ```
- In this file, there were some env variables stored in .env file located at the root level of **backend**
    ```
    DB_HOST=localhost
    DB_NAME=sakila
    DB_USER=root
    DB_PASSWORD=vOvieTlonG0108@
    NODE_ENV=development
    ```
- Then I added that sequelize instance into server initialization in index.js, making sure my server is connected to MySQL database before running
    ```js
    import express from "express";
    import sequelize from "./configs/database.js";

    const app = express();
    app.use(express.json());
    const port = 3000;

    app.get('/', (req, res) => {
        res.send('Express connected!');
    });
    const startServer = async () => {
        try {
            // console.log(sequelize.config)
            await sequelize.authenticate();
            console.log("DATABASE CONNECTED!!!")
            await sequelize.sync({force:false});
            app.listen(port, () => {
                console.log("Server running on port: " + port);
            })
        } catch (error) {
            console.log(error.stack)
        }
    }
    startServer();    

    ```
- This message appearing in the terminal when starting the server equals my database is connected: 
    ```powershell
        > seminar1@1.0.0 dev
        > nodemon index.js

        [nodemon] 3.1.10
        [nodemon] to restart at any time, enter `rs`
        [nodemon] watching path(s): *.*
        [nodemon] watching extensions: js,mjs,cjs,json
        [nodemon] starting `node index.js`
        [dotenv@17.2.3] injecting env (5) from .env -- tip: 🛠️  run anywhere with `dotenvx run -- yourcommand`
        [dotenv@17.2.3] injecting env (0) from .env -- tip: 🛠️  run anywhere with `dotenvx run -- yourcommand`
        Executing (default): SELECT 1+1 AS result
        DATABASE CONNECTED!!!
        Executing (default): SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = 'actor' AND TABLE_SCHEMA = 'sakila'
        Executing (default): SHOW INDEX FROM `actor``
    ```
## 4. Create routers and controllers for "/actors" endpoints
- A model of actors table was created called **actor.model.js**, where I defined a Sequelize Model to be used for querying data from MySQL Database:
    ```js
    import { DataTypes } from 'sequelize';
    import sequelize from '../configs/database.js'; // Import the connection

    const Actor = sequelize.define('Actor', {
    // Model attributes are defined here
    actor_id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    first_name: {
        type: DataTypes.STRING,
        allowNull: false
    },
    last_name: {
        type: DataTypes.STRING,
        allowNull: false
    },
    last_update:{
        type: 'TIMESTAMP',
        defaultValue: sequelize.literal('CURRENT_TIMESTAMP'),
        allowNull: false
    }
    }, {
    // Other model options go here
    tableName: 'actor',   // Explicitly tell Sequelize the table name
    timestamps: false     // Disable timestamps (createdAt and updatedAt)
    });

    export default Actor;
    ```
- I created **routes** and **controllers** folders, where I placed routes and controllers for my API endpoints
- In controllers, I create **actor.controller.js** and create four controllers for POST, PUT, GET, DELETE. All controllers are exported as functions
    ```js
    import Actor from "../models/actor.model.js";
    export const getAllActors = async (req, res) => {
        ...
    }
    export const getActor = async (req, res) => {
        ...
    }
    export const postActor = async (req, res) => {
        ...
    }
    export const putActor = async (req, res) => {
        ...
    }
    export const deleteActor = async (req, res) => {
        ...
    }
    ```

- Then I created **actor.route.js** to receive requests of each api endpoint
    ```js
    import { Router } from "express";
    import { getActor, getAllActors, postActor, putActor, deleteActor } from "../controllers/actor.controller.js";
    const actorRoute = Router();

    actorRoute.get('/', getAllActors);
    actorRoute.get('/:id', getActor);
    actorRoute.post('/', postActor);
    actorRoute.put('/:id', putActor);
    actorRoute.delete('/:id', deleteActor)

    export default actorRoute;
    ```
- **actorRoute** was then used as a middleware inside index.js, where it handled all of incoming requests upon **actors** api endpoints.
    ```js
    import express from "express";
    import sequelize from "./configs/database.js";
    import actorRoute from "./routes/actor.route.js";
    import { configDotenv } from "dotenv";
    configDotenv()
    const app = express();
    app.use(express.json());
    const port = 3000;

    app.get('/', (req, res) => {
        res.send('MySQL + Express connected!');
    });

    app.use('/actors', actorRoute)
    const startServer = async () => {
        try {
            // console.log(sequelize.config)
            await sequelize.authenticate();
            console.log("DATABASE CONNECTED!!!")
            await sequelize.sync({force:false});
            app.listen(port, () => {
                console.log("Server running on port: " + port);
            })
        } catch (error) {
            console.log(error.stack)
        }
    }

    startServer();
    ```
## 5. Create sample requests and test api endpoints
- Install VS Code REST Client extension and create **./requests/actor.request.http**
    ```js
    GET http://localhost:3000/actors
    ###
    GET http://localhost:3000/actors/1
    ###
    POST http://localhost:3000/actors
    Content-Type: application/json

    {
    "first_name": "Ryan",
    "last_name": "Reynolds"
    }
    ###
    POST http://localhost:3000/actors
    Content-Type: application/json

    {
        "first_name": "Ryan"
    }
    ###
    DELETE  http://localhost:3000/actors/1
    ###
    PUT http://localhost:3000/actors/2
    Content-Type: application/json

    {
        "first_name": "Vo",
        "last_name": "Viet Long"

    }
    ```
- Run the server
    ```npm run dev``` 
- Click on **"Send Request"** (Only appear after) on a request to test me API. For example:
    ```js
    POST http://localhost:3000/actors
    Content-Type: application/json

    {
    "first_name": "Ryan",
    "last_name": "Reynolds"
    }
    ```
- And receive this response:
    ```http
    HTTP/1.1 200 OK
    X-Powered-By: Express
    Content-Type: application/json; charset=utf-8
    Content-Length: 101
    ETag: W/"65-pm0Kj8vWTCSPHc8BmlvnXP2Uo7g"
    Date: Fri, 24 Oct 2025 16:18:05 GMT
    Connection: close

    {
    "last_update": {
        "val": "CURRENT_TIMESTAMP"
    },
    "actor_id": 202,
    "first_name": "Ryan",
    "last_name": "Reynolds"
    }
    ```
- So my RESTful API worked as intended